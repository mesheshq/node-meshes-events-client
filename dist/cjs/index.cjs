"use strict";var m=Object.defineProperty;var P=Object.getOwnPropertyDescriptor;var x=Object.getOwnPropertyNames;var O=Object.prototype.hasOwnProperty;var S=(a,e)=>{for(var t in e)m(a,t,{get:e[t],enumerable:!0})},T=(a,e,t,i)=>{if(e&&typeof e=="object"||typeof e=="function")for(let s of x(e))!O.call(a,s)&&s!==t&&m(a,s,{get:()=>e[s],enumerable:!(i=P(e,s))||i.enumerable});return a};var R=a=>T(m({},"__esModule",{value:!0}),a);var U={};S(U,{MeshesApiError:()=>r,MeshesEventsClient:()=>b,default:()=>M});module.exports=R(U);var r=class extends Error{constructor(e,t){super(e),this.name=this.constructor.name,typeof t<"u"&&(this.data=t)}};r.prototype.toJSON=function(a=!1){let e=a===!0?{stack:this.stack}:{};return typeof this.data>"u"?{name:this.name,message:this.message,...e}:{name:this.name,message:this.message,data:this.data,...e}};var y=async a=>{let e=await a.text();if(!e)return null;try{return JSON.parse(e)}catch{return e}},p=a=>a!=null&&a!==""&&!(typeof a=="string"&&a.trim().length===0)&&!(Array.isArray(a)&&a.length===0)&&!(typeof a=="object"&&!Array.isArray(a)&&Object.keys(a).length===0);var $=/^mesh_pub_([A-Za-z0-9\-.]+)_([A-Za-z0-9\-.]+)_([^_]+)$/,A=3e4,I=new Set(["x-meshes-publishable-key","x-meshes-client","content-type","accept"]),k=["POST"],j={version:"v1",timeout:5e3,debug:!1},w=class{#r;#a;#i;#u;#h;#s;constructor(e,t={}){if(typeof e!="string"||!{publishableKey:$}.publishableKey.test(e))throw new r(`Missing or invalid publishable key: ${e}`);if(!t||typeof t!="object")throw new r(`Invalid options object: ${typeof t}`,t);if(t={...j,...t},typeof t.version!="string")throw new r(`Invalid API version: ${t.version}`);if(t.version!=="v1")throw new r(`Unsupported API version: ${t.version}`);if(typeof t.timeout<"u"){if(typeof t.timeout!="number")throw new r(`Invalid request timeout: ${t.timeout}`);if(t.timeout<1e3||t.timeout>A)throw new r(`Unsupported request timeout: ${t.timeout}`)}if(typeof t.headers<"u"){if(!t.headers||typeof t.headers!="object"||Array.isArray(t.headers))throw new r(`Invalid additional request headers: ${typeof t.headers}`,t.headers);for(let[s,d]of Object.entries(t.headers)){if(typeof d!="string")throw new r(`Invalid request header value for ${s}: ${typeof d}`,t.headers);if(I.has(s.toLowerCase()))throw new r(`Header not allowed: ${s}`,t.headers)}}this.#a=t,this.#r=e,this.#i=t.apiBaseUrl??`https://events.meshes.io/api/${t.version}`,this.#u={...this.#d(t.headers),"X-Meshes-Client":"Meshes Events Client v1.0.0","Content-Type":"application/json",Accept:"application/json"},this.#h=t.timeout,this.#s=t.debug===!0}#e(e){this.#s&&console.debug(...arguments)}#t(e){this.#s&&console.error(...arguments)}#l(e){if(this.#r)e.headers["X-Meshes-Publishable-Key"]=this.#r;else throw new r("No Publishable Key Data");return e}#n(e){if(!e||typeof e!="object")throw new r("Invalid event: must be an object",e);if(typeof e.event!="string"||!e.event.trim())throw new r("Invalid event: missing 'event' string",e);if(!e.payload||typeof e.payload!="object"||Array.isArray(e.payload))throw new r("Invalid event: missing 'payload' object",e);if(!Object.values(e.payload).some(p))throw new r("Invalid event: payload must contain at least one value",e)}#d(e){if(!e||typeof e!="object")return{};let t={};for(let[i,s]of Object.entries(e)){if(typeof i!="string"||typeof s!="string"){this.#e("Invalid Header",i,s);continue}let d=i.trim(),l=s.trim();!d||!l||I.has(d.toLowerCase())||(t[d]=l)}return t}#f(e,t){this.#e("Request Options",e,t?"Callback":"Promise");let i=globalThis.AbortController??void 0,s=i?new i:void 0,d=typeof(e==null?void 0:e.timeout)=="number"?e.timeout:this.#h,l=i?setTimeout(()=>s==null?void 0:s.abort(),d):void 0;s===void 0&&this.#e("AbortController","Not Supported; Timeouts won't be enforced");let E=new Promise((n,c)=>{var g;if(typeof e!="object")throw this.#e("Invalid Request Options",e),new r("Invalid request options",e);let o=(g=e==null?void 0:e.method)==null?void 0:g.toUpperCase();if(!o||typeof o!="string")throw this.#e("Invalid Request Method",e),new r("Invalid request method",e);if(!k.includes(o))throw this.#e("Invalid Request Method Option",e),new r("Unsupported request method",e);if(!(e!=null&&e.path)||typeof e.path!="string"||e.path.trim().length===0||e.path.trim()==="/")throw this.#e("Invalid Request Path",e),new r("Invalid request path",e);if(typeof(e==null?void 0:e.timeout)<"u"){if(typeof e.timeout!="number")throw this.#e("Invalid Request Timeout",e),new r("Invalid request timeout",e);if(e.timeout<1e3||e.timeout>A)throw this.#e("Unsupported Request Timeout",e),new r("Unsupported request timeout",e)}if(typeof e.query<"u"&&(!e.query||typeof e.query!="object"||Array.isArray(e.query)))throw this.#e("Invalid Request Query Params",e),new r("Invalid request query params",e);try{let f=e.query?`?${new URLSearchParams(e.query).toString()}`:"",q=this.#l({method:o,headers:{...this.#d(e.headers),...this.#u},body:e.body?typeof e.body=="string"?e.body:JSON.stringify(e.body):null,signal:s==null?void 0:s.signal}),v=e.path.charAt(0)!=="/"?`/${e.path}`:e.path;return this.#e("Fetch Options",{method:q.method,path:v,query:f}),fetch(`${this.#i}${v}${f}`,q).then(u=>{u.ok?y(u).then(h=>{this.#e("Response Success"),n(h)}).catch(h=>{this.#t("Response Parsing Error",h),c(new r("Error parsing response data",h))}):y(u).then(h=>{this.#e("Response Error",h),c(new r("Meshes API request failed",{status:u.status,statusText:u.statusText,data:h}))}).catch(h=>{this.#t("Response Parsing Failure",h),c(new r("Error parsing request failure",{status:u.status,statusText:u.statusText,error:h}))})}).catch(u=>{this.#t("Request Failure",u),c(new r("Request Failure",u))})}catch(f){throw this.#t("Unexpected Error",f),c(new r("Unexpected Error",f)),f}}).then(n=>{if(this.#e("Promise Success",n),t){this.#e("Promise Success","Callback Success"),t(null,n);return}return n}).catch(n=>{if(this.#e("Promise Error",n),t){this.#e("Promise Error","Callback Error"),t(n);return}throw n}).finally(()=>{l&&clearTimeout(l)});if(!t)return this.#e("Promise Returned","No callback"),E}emit(e,t={},i=void 0){return this.#n(e),this.#f({...this.#a,...t,path:"/events",method:"POST",body:e},i)}emitBatch(e,t={},i=void 0){if(!Array.isArray(e))throw new r("Events must be an array",e);if(e.length===0)throw new r("Events array cannot be empty");if(e.length>100)throw new r("Bulk emit supports up to 100 events per request",{count:e.length});for(let s of e)this.#n(s);return this.#f({...this.#a,...t,path:"/events/bulk",method:"POST",body:e},i)}},b=w;var M=b;0&&(module.exports={MeshesApiError,MeshesEventsClient});
/**
 * JavaScript Meshes Events Client
 * @module meshes-events-client
 * @license MIT
 * @since 1.0.0
 * @description Meshes events client for emitting events with a publishable key.
 * @repository https://github.com/mesheshq/node-meshes-events-client
 */
