var r=class extends Error{constructor(e,t){super(e),this.name=this.constructor.name,typeof t<"u"&&(this.data=t)}};r.prototype.toJSON=function(s=!1){let e=s===!0?{stack:this.stack}:{};return typeof this.data>"u"?{name:this.name,message:this.message,...e}:{name:this.name,message:this.message,data:this.data,...e}};var m=async s=>{let e=await s.text();if(!e)return null;try{return JSON.parse(e)}catch{return e}},q=s=>s!=null&&s!==""&&!(typeof s=="string"&&s.trim().length===0)&&!(Array.isArray(s)&&s.length===0)&&!(typeof s=="object"&&!Array.isArray(s)&&Object.keys(s).length===0);var E=/^mesh_pub_([A-Za-z0-9\-.]+)_([A-Za-z0-9\-.]+)_([^_]+)$/,v=3e4,p=new Set(["x-meshes-publishable-key","x-meshes-client","content-type","accept"]),P=["POST"],x={version:"v1",timeout:5e3,debug:!1},y=class{#r;#a;#i;#u;#h;#s;constructor(e,t={}){if(typeof e!="string"||!{publishableKey:E}.publishableKey.test(e))throw new r(`Missing or invalid publishable key: ${e}`);if(!t||typeof t!="object")throw new r(`Invalid options object: ${typeof t}`,t);if(t={...x,...t},typeof t.version!="string")throw new r(`Invalid API version: ${t.version}`);if(t.version!=="v1")throw new r(`Unsupported API version: ${t.version}`);if(typeof t.timeout<"u"){if(typeof t.timeout!="number")throw new r(`Invalid request timeout: ${t.timeout}`);if(t.timeout<1e3||t.timeout>v)throw new r(`Unsupported request timeout: ${t.timeout}`)}if(typeof t.headers<"u"){if(!t.headers||typeof t.headers!="object"||Array.isArray(t.headers))throw new r(`Invalid additional request headers: ${typeof t.headers}`,t.headers);for(let[a,d]of Object.entries(t.headers)){if(typeof d!="string")throw new r(`Invalid request header value for ${a}: ${typeof d}`,t.headers);if(p.has(a.toLowerCase()))throw new r(`Header not allowed: ${a}`,t.headers)}}this.#a=t,this.#r=e,this.#i=t.apiBaseUrl??`https://events.meshes.io/api/${t.version}`,this.#u={...this.#d(t.headers),"X-Meshes-Client":"Meshes Events Client v1.0.0","Content-Type":"application/json",Accept:"application/json"},this.#h=t.timeout,this.#s=t.debug===!0}#e(e){this.#s&&console.debug(...arguments)}#t(e){this.#s&&console.error(...arguments)}#l(e){if(this.#r)e.headers["X-Meshes-Publishable-Key"]=this.#r;else throw new r("No Publishable Key Data");return e}#n(e){if(!e||typeof e!="object")throw new r("Invalid event: must be an object",e);if(typeof e.event!="string"||!e.event.trim())throw new r("Invalid event: missing 'event' string",e);if(!e.payload||typeof e.payload!="object"||Array.isArray(e.payload))throw new r("Invalid event: missing 'payload' object",e);if(!Object.values(e.payload).some(q))throw new r("Invalid event: payload must contain at least one value",e)}#d(e){if(!e||typeof e!="object")return{};let t={};for(let[i,a]of Object.entries(e)){if(typeof i!="string"||typeof a!="string"){this.#e("Invalid Header",i,a);continue}let d=i.trim(),l=a.trim();!d||!l||p.has(d.toLowerCase())||(t[d]=l)}return t}#f(e,t){this.#e("Request Options",e,t?"Callback":"Promise");let i=globalThis.AbortController??void 0,a=i?new i:void 0,d=typeof(e==null?void 0:e.timeout)=="number"?e.timeout:this.#h,l=i?setTimeout(()=>a==null?void 0:a.abort(),d):void 0;a===void 0&&this.#e("AbortController","Not Supported; Timeouts won't be enforced");let I=new Promise((n,c)=>{var w;if(typeof e!="object")throw this.#e("Invalid Request Options",e),new r("Invalid request options",e);let o=(w=e==null?void 0:e.method)==null?void 0:w.toUpperCase();if(!o||typeof o!="string")throw this.#e("Invalid Request Method",e),new r("Invalid request method",e);if(!P.includes(o))throw this.#e("Invalid Request Method Option",e),new r("Unsupported request method",e);if(!(e!=null&&e.path)||typeof e.path!="string"||e.path.trim().length===0||e.path.trim()==="/")throw this.#e("Invalid Request Path",e),new r("Invalid request path",e);if(typeof(e==null?void 0:e.timeout)<"u"){if(typeof e.timeout!="number")throw this.#e("Invalid Request Timeout",e),new r("Invalid request timeout",e);if(e.timeout<1e3||e.timeout>v)throw this.#e("Unsupported Request Timeout",e),new r("Unsupported request timeout",e)}if(typeof e.query<"u"&&(!e.query||typeof e.query!="object"||Array.isArray(e.query)))throw this.#e("Invalid Request Query Params",e),new r("Invalid request query params",e);try{let f=e.query?`?${new URLSearchParams(e.query).toString()}`:"",b=this.#l({method:o,headers:{...this.#d(e.headers),...this.#u},body:e.body?typeof e.body=="string"?e.body:JSON.stringify(e.body):null,signal:a==null?void 0:a.signal}),g=e.path.charAt(0)!=="/"?`/${e.path}`:e.path;return this.#e("Fetch Options",{method:b.method,path:g,query:f}),fetch(`${this.#i}${g}${f}`,b).then(u=>{u.ok?m(u).then(h=>{this.#e("Response Success"),n(h)}).catch(h=>{this.#t("Response Parsing Error",h),c(new r("Error parsing response data",h))}):m(u).then(h=>{this.#e("Response Error",h),c(new r("Meshes API request failed",{status:u.status,statusText:u.statusText,data:h}))}).catch(h=>{this.#t("Response Parsing Failure",h),c(new r("Error parsing request failure",{status:u.status,statusText:u.statusText,error:h}))})}).catch(u=>{this.#t("Request Failure",u),c(new r("Request Failure",u))})}catch(f){throw this.#t("Unexpected Error",f),c(new r("Unexpected Error",f)),f}}).then(n=>{if(this.#e("Promise Success",n),t){this.#e("Promise Success","Callback Success"),t(null,n);return}return n}).catch(n=>{if(this.#e("Promise Error",n),t){this.#e("Promise Error","Callback Error"),t(n);return}throw n}).finally(()=>{l&&clearTimeout(l)});if(!t)return this.#e("Promise Returned","No callback"),I}emit(e,t={},i=void 0){return this.#n(e),this.#f({...this.#a,...t,path:"/events",method:"POST",body:e},i)}emitBatch(e,t={},i=void 0){if(!Array.isArray(e))throw new r("Events must be an array",e);if(e.length===0)throw new r("Events array cannot be empty");if(e.length>100)throw new r("Bulk emit supports up to 100 events per request",{count:e.length});for(let a of e)this.#n(a);return this.#f({...this.#a,...t,path:"/events/bulk",method:"POST",body:e},i)}},A=y;var j=A;export{r as MeshesApiError,A as MeshesEventsClient,j as default};
/**
 * JavaScript Meshes Events Client
 * @module meshes-events-client
 * @license MIT
 * @since 1.0.0
 * @description Meshes events client for emitting events with a publishable key.
 * @repository https://github.com/mesheshq/node-meshes-events-client
 */
