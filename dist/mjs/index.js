var r=class extends Error{constructor(e,t){super(e),this.name=this.constructor.name,typeof t<"u"&&(this.data=t)}};r.prototype.toJSON=function(f=!1){let e=f===!0?{stack:this.stack}:{};return typeof this.data>"u"?{name:this.name,message:this.message,...e}:{name:this.name,message:this.message,data:this.data,...e}};var o=async f=>{let e=await f.text();if(!e)return null;try{return JSON.parse(e)}catch{return e}};var P=/^mesh_pub_([A-Za-z0-9\-.]+)_([A-Za-z0-9\-.]+)_([^_]+)$/,v=3e4,q=new Set(["x-meshes-publishable-key","x-meshes-client","content-type","accept"]),E=["POST"],x={version:"v1",timeout:5e3,debug:!1},y=class{#r;#a;#i;#u;#h;#s;constructor(e,t={}){if(typeof e!="string"||!{publishableKey:P}.publishableKey.test(e))throw new r(`Missing or invalid publishable key: ${e}`);if(!t||typeof t!="object")throw new r(`Invalid options object: ${typeof t}`,t);if(t={...x,...t},typeof t.version!="string")throw new r(`Invalid API version: ${t.version}`);if(t.version!=="v1")throw new r(`Unsupported API version: ${t.version}`);if(typeof t.timeout<"u"){if(typeof t.timeout!="number")throw new r(`Invalid request timeout: ${t.timeout}`);if(t.timeout<1e3||t.timeout>v)throw new r(`Unsupported request timeout: ${t.timeout}`)}if(typeof t.headers<"u"){if(!t.headers||typeof t.headers!="object"||Array.isArray(t.headers))throw new r(`Invalid additional request headers: ${typeof t.headers}`,t.headers);for(let[a,n]of Object.entries(t.headers)){if(typeof n!="string")throw new r(`Invalid request header value for ${a}: ${typeof n}`,t.headers);if(q.has(a.toLowerCase()))throw new r(`Header not allowed: ${a}`,t.headers)}}this.#a=t,this.#r=e,this.#i=t.apiBaseUrl??`https://api.meshes.io/api/${t.version}`,this.#u={...this.#d(t.headers),"X-Meshes-Client":"Meshes Events Client v1.0.0","Content-Type":"application/json",Accept:"application/json"},this.#h=t.timeout,this.#s=t.debug===!0}#e(e){this.#s&&console.debug(...arguments)}#t(e){this.#s&&console.error(...arguments)}#l(e){if(this.#r)e.headers["X-Meshes-Publishable-Key"]=this.#r;else throw new r("No Publishable Key Data");return e}#n(e){if(!e||typeof e!="object")throw new r("Invalid event: must be an object",e);if(typeof e.event!="string"||!e.event.trim())throw new r("Invalid event: missing 'event' string",e);if(!e.payload||typeof e.payload!="object")throw new r("Invalid event: missing 'payload' object",e);if(typeof e.payload.email!="string"||!e.payload.email.trim())throw new r("Invalid event: missing payload.email",e)}#d(e){if(!e||typeof e!="object")return{};let t={};for(let[s,a]of Object.entries(e)){if(typeof s!="string"||typeof a!="string"){this.#e("Invalid Header",s,a);continue}let n=s.trim(),l=a.trim();!n||!l||q.has(n.toLowerCase())||(t[n]=l)}return t}#f(e,t){this.#e("Request Options",e,t?"Callback":"Promise");let s=globalThis.AbortController??void 0,a=s?new s:void 0,n=typeof(e==null?void 0:e.timeout)=="number"?e.timeout:this.#h,l=s?setTimeout(()=>a==null?void 0:a.abort(),n):void 0;a===void 0&&this.#e("AbortController","Not Supported; Timeouts won't be enforced");let I=new Promise((h,c)=>{var w;if(typeof e!="object")throw this.#e("Invalid Request Options",e),new r("Invalid request options",e);let m=(w=e==null?void 0:e.method)==null?void 0:w.toUpperCase();if(!m||typeof m!="string")throw this.#e("Invalid Request Method",e),new r("Invalid request method",e);if(!E.includes(m))throw this.#e("Invalid Request Method Option",e),new r("Unsupported request method",e);if(!(e!=null&&e.path)||typeof e.path!="string"||e.path.trim().length===0||e.path.trim()==="/")throw this.#e("Invalid Request Path",e),new r("Invalid request path",e);if(typeof(e==null?void 0:e.timeout)<"u"){if(typeof e.timeout!="number")throw this.#e("Invalid Request Timeout",e),new r("Invalid request timeout",e);if(e.timeout<1e3||e.timeout>v)throw this.#e("Unsupported Request Timeout",e),new r("Unsupported request timeout",e)}if(typeof e.query<"u"&&(!e.query||typeof e.query!="object"||Array.isArray(e.query)))throw this.#e("Invalid Request Query Params",e),new r("Invalid request query params",e);try{let d=e.query?`?${new URLSearchParams(e.query).toString()}`:"",b=this.#l({method:m,headers:{...this.#d(e.headers),...this.#u},body:e.body?typeof e.body=="string"?e.body:JSON.stringify(e.body):null,signal:a==null?void 0:a.signal}),g=e.path.charAt(0)!=="/"?`/${e.path}`:e.path;return this.#e("Fetch Options",{method:b.method,path:g,query:d}),fetch(`${this.#i}${g}${d}`,b).then(i=>{i.ok?o(i).then(u=>{this.#e("Response Success"),h(u)}).catch(u=>{this.#t("Response Parsing Error",u),c(new r("Error parsing response data",u))}):o(i).then(u=>{this.#e("Response Error",u),c(new r("Meshes API request failed",{status:i.status,statusText:i.statusText,data:u}))}).catch(u=>{this.#t("Response Parsing Failure",u),c(new r("Error parsing request failure",{status:i.status,statusText:i.statusText,error:u}))})}).catch(i=>{this.#t("Request Failure",i),c(new r("Request Failure",i))})}catch(d){throw this.#t("Unexpected Error",d),c(new r("Unexpected Error",d)),d}}).then(h=>{if(this.#e("Promise Success",h),t){this.#e("Promise Success","Callback Success"),t(null,h);return}return h}).catch(h=>{if(this.#e("Promise Error",h),t){this.#e("Promise Error","Callback Error"),t(h);return}throw h}).finally(()=>{l&&clearTimeout(l)});if(!t)return this.#e("Promise Returned","No callback"),I}emit(e,t={},s=void 0){return this.#n(e),this.#f({...this.#a,...t,path:"/events",method:"POST",body:e},s)}emitBatch(e,t={},s=void 0){if(!Array.isArray(e))throw new r("Events must be an array",e);if(e.length===0)throw new r("Events array cannot be empty");if(e.length>100)throw new r("Bulk emit supports up to 100 events per request",{count:e.length});for(let a of e)this.#n(a);return this.#f({...this.#a,...t,path:"/events/bulk",method:"POST",body:e},s)}},p=y;var O=p;export{r as MeshesApiError,p as MeshesEventsClient,O as default};
/**
 * JavaScript Meshes Events Client
 * @module meshes-events-client
 * @license MIT
 * @since 1.0.0
 * @description Meshes events client for emitting events with a publishable key.
 * @repository https://github.com/mesheshq/node-meshes-events-client
 */
